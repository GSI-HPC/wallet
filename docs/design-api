                            Wallet Server API

Introduction

    Here is the specification for the API that components of the wallet
    server will implement.  This is the document you should read if you're
    planning on extending the wallet system.  There are two pluggable
    components in the wallet server: the implementation of a particular
    object type (which amounts mostly to storage and retrieval), and the
    ACL implementation.

    Also see the documentation for Wallet::Object and Wallet::ACL::Base,
    which contain some additional information about creating new object
    and ACL verifier implementations.

Object API

  new(NAME, TYPE, DBH)

    Creates a new object with the given object name and type based on data
    already in the database.  Takes a database handle, which should be
    stored with the object and used for any further operations.  This
    method should inherit from the generic Wallet::Object::Base object,
    which implements the following methods:

        new(NAME, DBH)
        create(NAME, DBH)
        owner([ACL-ID, PRINCIPAL, HOSTNAME [, DATETIME]])
        acl(TYPE [, ACL-ID, PRINCIPAL, HOSTNAME [, DATETIME]])
        expires([DATETIME, PRINCIPAL, HOSTNAME [, DATETIME]])
        store(DATA, PRINCIPAL, HOSTNAME [, DATETIME])
        show()
        destroy(PRINCIPAL, HOSTNAME [, DATETIME])
        error()

    that manipulate the basic object data.  Generally all this function
    needs to do is call the parent new() constructor.  If the object
    couldn't be found, throws an exception.  (Just returning undef would
    provide no way of communicating the error message.)

  create(NAME, TYPE, DBH, PRINCIPAL, HOSTNAME [, DATETIME])

    Like new(), but instead creates a new entry in the database with the
    given name.  As with new(), the generic function will normally do all
    of the work.  Takes some additional information to put into the
    created fields in the database.  If the object already exists or
    creating it fails, throws an exception.  (Just returning undef would
    provide no way of communicating the error message.)

  destroy(PRINCIPAL, HOSTNAME [, DATETIME])

    Destroys the given object.  This should include destroying any
    representation of the object in other systems as well (such as
    deleting Kerberos principals out of a KDC).  Takes the information
    about who is doing the deletion to store log entries.  The result is
    true on success and false on failure.  On error, the caller should
    call error() to get the error text.

  get(PRINCIPAL, HOSTNAME [, DATETIME])

    Applied to a returned object, retrieves the data contained in the
    object in question.  Takes the information about who is doing the
    retrieval so that the database metadata can be updated.  The result is
    either the relevant data or undef in the event of an error.  On error,
    the caller should call error() to get the error text.

  store(DATA, PRINCIPAL, HOSTNAME [, DATETIME])

    Store user-supplied data into the given object.  This may not be
    supported by all backends (for instance, backends that automatically
    generate the data will not support this).  Takes the information about
    who is doing the store so that the database metadata can be updated.
    The result is true on success and false on failure.  On error, the
    caller should call error() to get the error text.

  show()

    Returns a formatted text description of the object suitable for human
    display, or undef on error.  On error, the caller should call error()
    to get the error text.

  error()

    Returns the error text from the last failed call.

ACL API

  new(ACL, DBH)

    Instantiate a new ACL object with the given ACL ID or name.  Takes the
    database handle to use for retrieving metadata.  Returns a new ACL
    object if the ACL was found or undef if it wasn't.

  create(NAME, DBH, PRINCIPAL, HOSTNAME [, DATETIME])

    Similar to new() but instead creates a new ACL record in the database
    with the given NAME (and with no lines).  Returns the new object on
    success and undef on failure.

  add(SCHEME, INSTANCE, PRINCIPAL, HOSTNAME [, DATETIME])

    Add the given ACL line (given by SCHEME and INSTANCE) to this ACL.
    Returns true on success and false on failure.  On failure, the caller
    should call error() to get the error message.

  remove(SCHEME, INSTANCE, PRINCIPAL, HOSTNAME [, DATETIME])

    Remove the given ACL line (given by SCHEME and INSTANCE) from this
    ACL.  Returns true on success and false on failure.  On failure, the
    caller should call error() to get the error message.

  rename(NAME)

    Rename this ACL.  This changes the name used for human convenience but
    not the system-generated ACL ID that is used to reference this ACL.
    Returns true on success and false on failure.  On failure, the caller
    should call error() to get the error message.

  destroy(PRINCIPAL, HOSTNAME [, DATETIME])

    Destroys this ACL from the database.  Note that this will fail due to
    integrity constraint errors if the ACL is still referenced by any
    object.  Returns ture on success and false on failure.  On failure,
    the caller should call error() to get the error message.

  check(PRINCIPAL)

    Checks whether the given PRINCIPAL should be allowed access given ACL.
    Returns 1 if access was granted, 0 if access is declined, and undef on
    error.  On error, the caller should call error() to get the error text
    but generally should continue with checking other ACLs.  Any errors
    found by the individual ACL verifiers can be retrieved by calling
    check_errors().  Errors from individual ACL verifiers will not result
    in an error return from check().

  check_errors()

    Return (as a list in array context and a string with newlines between
    errors and at the end of the last error in scalar context) the errors,
    if any, returned by ACL verifiers for the last check operation.

  error()

    Returns the error text of the last error.

ACL Verifier API

  new()

    Creates a persistant ACL verifier for the given ACL type.  This may do
    nothing, but some ACL verifiers require some persistant data, like a
    persistant LDAP connection.

  check(PRINCIPAL, ACL)

    Checks whether the given PRINCIPAL should be allowed access given ACL.
    Returns 1 if access is granted, 0 if access is declined, and undef on
    error.  On error, the caller should call error() to get the error text
    but generally should continue with checking other ACLs.

  error()

    Returns the error text of the last error.
